# Nathan Zhu Monday August 5th, 2019 3:44 pm
# Leetcode 924 | hard | hard if you don't know union find
#
# Question: 
# Question explained badly.
# Some nodes in a graph are infected, and they will infect all other nodes in that subgraph.
# So, if there is a subgraph with only 1 infected node, fixing it will ensure none of nodes in that subgraph are infected
# Minimize the spread of infection.
#
# So, question is, find the largest subgraph with only one infected node.  If there is a tie, choose the initial
# that is smaller.
#
# Intuition:
# Union found all nodes.
# Count the union size of each union set.
# Count the malware number of each union set.

# Return the biggest union's malware if there is one and only one malware.
# If no such union that has and has only one malware,
# return the malware with minimum index.
import collections

def minMalwareSpread(graph, initial):
    """
    :type graph: List[List[int]]
    :type initial: List[int]
    :rtype: int
    """
    def find(x):
        if x != parent[x]:
            # This like makes subsequent find calls O(1)
            if parent[x] != parent[parent[x]]:
                parent[x] = find(parent[x])
        return parent[x]
    
    def union(a, b):
        parent[find(a)] = find(b)
    
    n = len(graph)
    parent = range(n)
    for row in range(len(graph)):
        for col in range(row + 1, len(graph[0])):
            if graph[row][col] == 1:
                union(row, col)
                
    # flatten all things in union find
    # this is important. Ensures everying with same parents[i] is in same subgraph
    for i in range(n): find(i)
    
    # areas   maps :  node idx -> number of nodes in that part of the graph
    # malware maps :  node idx -> number of malware nodes in that part of the graph
    areas = collections.Counter(parent)
    malware = collections.Counter(parent[i] for i in initial)
    
    # Try to find the node that if we "fix" reduces the most malware spread
    savedarea, res = 0, min(initial)
    for i in initial:
        if malware[parent[i]] == 1:
            # We find a node that if fixed reduces more malware spread than current node
            if areas[parent[i]] > savedarea:
                savedarea, res = areas[parent[i]], i
            # We find a node that if fixed reduces same malware spread, store lesser of the two indices
            elif areas[parent[i]] == savedarea:
                res = min(i, res)
                
    return res

if __name__ == "__main__":
    print(minMalwareSpread([[1,1,1,0,0,0],
                           [0,1,0,0,0,0],
                           [0,0,1,0,0,0], 
                           [0,0,0,1,1,0],
                           [0,0,0,0,1,1],
                           [0,0,0,1,0,1]], [0, 1]))
    # print(minMalwareSpread([[1,0,0,0,0,0,0],
    #                         [0,1,0,1,1,0,0],
    #                         [0,0,1,0,0,1,1], 
    #                         [0,0,0,1,0,0,0],
    #                         [0,0,0,0,1,0,0],
    #                         [0,0,0,1,0,1,0],
    #                         [0,0,0,1,0,0,1]], [0, 1]))
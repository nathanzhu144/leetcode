# Nathan Zhu American Express 10:50 pm.  Wednesday June 10th, 2019 36th floor after korean BBQ with team
# Leetcode 718 | medium | hard methink
# Category: DP
#  
# Question: Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays.
#
# https://leetcode.com/problems/maximum-length-of-repeated-subarray/
#  
# Damn this problem is hard.  I'm honestly really impressed by my top-down version (I gave up so many times),
# and finally stole the soln from someone who got it working (TLE still).  The top-down should be a leetcode hard.
# 
# The bottom-up had a cool array-padding trick, but it wasn't too bad.
#  

def max_len_repeated_subarray_bottom_up(A, B):
    # should j be inclusive
    # 
    ret = 0
    mem = [[0 for j in range(len(B) + 1)] for i in range(len(A) + 1)]
    
    # Suppose A is "DOG" B is "DOOG"
    #   
    #         D O O G  (strB)
    #       0 0 0 0 0
    #     D 0 1 0 0 0
    #     O 0 0 2 1 0
    #     A 0 0 0 0 0
    #(strA)
    #   Note that we pad the array and set everything to 0s. What this does is when we are calculating
    #   things on the edge of the array, like mem[1][1].  Suppose A[i - 1] == B[i - 1], we could just do
    #   mem[1][1] = 1 + mem[0][0], which mem[0][0] is conveniently 0.
    #
    #  NOTE: mem[i][j] measues LONGEST repeating subarray ENDING at end of both A and B, where i and j
    #        are LENGTHS of A and B, NOT indices.
    #
    #        Ex. mem[1][1] of "D" and "D" is 1 (note how mem[0][0] is not defined or 0 here)
    for i in range(1, len(A) + 1):
        for j in range(1, len(B) + 1):
            # Since i and j are string lengths, we need to do A[i - 1] == B[j - 1] instead of A[i] == B[j]
            # Note that if back to chars are not equal, the mem[i][j] remains 0, as it should be
            if A[i - 1] == B[j - 1]: mem[i][j] = mem[i - 1][j - 1] + 1
            # store max length so far
            # NOTE: Suppose we want the actual max common substring.  We could store starting index here too.
            ret = max(ret, mem[i][j])
    return ret


# The key point is that we memoize strings (A, B) on longest common string starting somewhere in
# A or B and ending at the end of A and B.  
#
# Ex. DOGAPPL
#        GPPL,  in this example "PPL" is longest common string ending at end of A and B
#          
# Ex. DOG
#     DOGA,     in this example "" is longest common string ending at end of A and B
#
def max_len_repeated_subarray_top_down(A, B):
    ret = [0]

    def helper(str1, str2, mem):
        if not str1 or not str2: return 0
        key = (str(str1), str(str2))
        if key in mem: return mem[key]

        # Note that max ending here is 0, unless last letter of A and B are the same
        # HOWEVER, if A and B have same last character it is not necessarily true that longest subarray will 
        # be generated by taking that last character
        max_ending_here = 0

        # we "take the last character"
        if str1[-1] == str2[-1]: max_ending_here = helper(str1[:-1], str2[:-1], mem) + 1

        # it is possible we can get longest subarrays by removing last character of str1 or str2
        # this is possibly true even when last character is the same
        decrease_str1 = helper(str1[:-1], str2, mem)
        decrease_str2 = helper(str1, str2[:-1], mem)

        # At this point, max subarray ending at this character is generated by:
        # 1. IF str1[-1] == str2[-1], THEN taking helper(str1[:-1], str2[:-1], mem) + 1
        # 2. taking last char off of str1
        # 3. taking last char off of str2
        ret[0] = max(ret[0], max_ending_here, decrease_str1, decrease_str2)

        # longest subarray ending here is not zero IFF str1[-1] == str2[-1]
        mem[key] = max_ending_here
        return mem[key]
    temp = dict()
    helper(A, B, temp)
    return ret[0]

if __name__ == "__main__":
    print(max_len_repeated_subarray_bottom_up([1,0], [1,0,0]))
#         [0,0,0,0,0,0,1,0,0,0]
# [0,0,0,0,0,0,0,1,0,0])
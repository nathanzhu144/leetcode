# Nathan Zhu May 21st, 2020. 6:03 pm.  Just finished work at Salesforce, day 4.
# Leetcode 924 | hard | kinda tricky?
# Category: Union find, but DFS can work
# 
# Insight is we want to find the large subgraph with exactly one infected node,
# and break ties by smaller index.

import collections

class UF(object):
    def __init__(self):
        self.parent = dict()    # maps node -> parent
        self.size = dict()      # maps parent -> size
        
    def touch(self, a):
        if a in self.parent: return
        self.parent[a] = a
        self.size[a] = 1
        
    def find(self, a):
        if self.parent[a] != a: self.parent[a] = self.find(self.parent[a])
        return self.parent[a]
    
    def join(self, a, b):
        p1, p2 = self.find(a), self.find(b)
        if p1 == p2: return
        self.parent[p1] = p2
        self.size[p2] += self.size[p1]
        del self.size[p1]
        
    def get_size(self, a):
        return self.size[self.find(a)]

class Solution(object):
    def minMalwareSpread(self, graph, initial):
        """
        :type graph: List[List[int]]
        :type initial: List[int]
        :rtype: int
        """
        if not graph or not graph[0]: return
        R, C = len(graph), len(graph[0])
        u = UF()
        
        for r in range(R):
            for c in range(r, C):
                if graph[r][c] == 1:
                    u.touch(r)
                    u.touch(c)
                    u.join(r, c)
        # We need to find all subgraphs with exactly one infected node
        num_inf = collections.Counter()
        for inf in initial:
            num_inf[u.find(inf)] += 1
            
        initial.sort(key=lambda x: u.get_size(x), reverse=True)
        for node in initial:
            if num_inf[u.find(node)] == 1: return node
            
        return initial[0] # removing no node will cchange final infected
                